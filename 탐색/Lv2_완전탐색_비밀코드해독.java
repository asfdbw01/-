/*
 * 문제 요약
 *   - 1부터 n까지의 정수 중 5개를 뽑아 만든 비밀 코드가 존재한다.
 *   - m번의 시도를 통해 5개의 정수를 입력하고, 비밀 코드와 몇 개가 일치하는지 시스템이 알려준다.
 *   - 주어진 m개의 시도와 그 결과를 바탕으로 가능한 비밀 코드 조합의 수를 구하라.

 * 입력
 *   - int n: 전체 숫자의 범위 (10 ≤ n ≤ 30)
 *   - int[][] q: m개의 시도 (각 시도는 길이 5, 오름차순 정수 배열, 1 ≤ q[i][j] ≤ n)
 *   - int[] ans: 각 시도에서 몇 개가 맞았는지 (길이 m, 각 원소는 0~5)

 * 출력
 *   - int: 조건을 만족하는 비밀 코드 조합의 개수

 * 핵심 포인트
 *   - 가능한 모든 5개 조합은 n ≤ 30이므로 비트마스킹으로 완전탐색 가능 (C(30, 5) ≈ 140,000)
 *   - 각 조합에 대해 m개의 조건을 모두 만족하는지 검증
 *   - 시간 제한 내에 탐색 + 검증이 가능하도록 비트 연산 최적화 필요
 */

class Solution {

    // 전체 가능한 조합 중에서 조건을 만족하는 조합의 개수를 세는 함수
    public int solution(int n, int[][] q, int[] ans) {
        int answer = 0;

        // 비트마스킹을 이용한 조합 탐색 (n개의 원소 중 5개를 고른 모든 조합)
        for (int bit = 0; bit < (1 << n); bit++) {
            if (Integer.bitCount(bit) == 5) { // 정확히 5개 원소가 선택된 경우만 고려
                answer += isPossible(bit, q, ans); // 조건 만족 여부 확인 후 누적
            }
        }

        return answer;
    }

    // 선택된 조합(bit)이 모든 조건을 만족하는지 확인하는 함수
    public int isPossible(int bit, int[][] q, int[] ans) {
        for (int i = 0; i < q.length; i++) {
            int count = 0;

            // 현재 조건 q[i] 안에 포함된 숫자 중에서,
            // 실제 조합(bit)에 포함된 숫자의 개수 세기
            for (int num : q[i]) {
                // num은 1-based이므로 (num - 1) 번째 비트가 1인지 확인
                if ((bit & (1 << (num - 1))) != 0) count++;
            }

            // 조건이 요구하는 개수와 다르면 이 조합은 불가능
            if (count != ans[i]) return 0;
        }

        // 모든 조건을 만족하면 유효한 조합
        return 1;
    }
}
