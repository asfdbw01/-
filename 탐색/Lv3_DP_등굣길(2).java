/*  
 * 문제 요약  
 *     - m x n 격자에서 집(1,1) → 학교(m,n)까지 물웅덩이를 피하면서  
 *       오른쪽 또는 아래쪽으로만 이동 가능한 **모든 경로의 수**를 구하는 문제  
 *
 * 입력  
 *     - m: 격자의 열 개수 (1 ≤ m ≤ 100)  
 *     - n: 격자의 행 개수 (1 ≤ n ≤ 100)  
 *     - puddles: 잠긴 지역의 좌표 배열 (최대 10개, 1-based 좌표)  
 *
 * 출력  
 *     - 오른쪽 또는 아래로만 움직여서 도달 가능한 경로의 수 % 1,000,000,007  
 *
 * 핵심 포인트  
 *     - DP 점화식: dp[i][j] = dp[i-1][j] + dp[i][j-1]  
 *     - 물웅덩이는 -1로 마킹하고 경로 누적 제외  
 *     - 이 DP는 "경로의 수"를 구하며, **"최단 거리"는 계산하지 않음**  
 *     - 거리까지 계산하고 싶다면 BFS 기반의 거리 우선 탐색이 필요함
 */

class Solution {
	
	public int solution(int m, int n, int[][] puddles) {
		int[][] dp = new int[n][m];
		
		// 물에 잠긴 지역을 -1로 마킹
		for (int[] loc : puddles) {
			dp[loc[1] - 1][loc[0] - 1] = -1;
		}
		
		dp[0][0] = 1; // 시작점 초기화
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				// 시작점 또는 물웅덩이는 건너뜀
				if ((i == 0 && j == 0) || dp[i][j] == -1) continue;
				
				// 위쪽 경로가 물웅덩이이면 0, 아니면 해당 값
				int top = (i == 0 || dp[i - 1][j] == -1) ? 0 : dp[i - 1][j];
				// 왼쪽 경로가 물웅덩이이면 0, 아니면 해당 값
				int left = (j == 0 || dp[i][j - 1] == -1) ? 0 : dp[i][j - 1];
				
				// 현재 위치의 경로 수 = 위쪽 + 왼쪽
				dp[i][j] = (top + left) % 1_000_000_007;
			}
		}
		
		return dp[n - 1][m - 1];
	}
}
