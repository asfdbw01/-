/*  
 * 문제 요약
 *     - 금액 n원을 거슬러 줄 수 있는 모든 조합의 수를 계산
 *     - 조합에 사용 가능한 동전 단위는 배열 money로 주어짐
 *     - 동전은 무한히 사용 가능하며, 순서가 다른 것은 같은 경우로 간주
 *
 * 입력  
 *     - int n: 1 이상 100,000 이하의 정수 (거슬러 줄 금액)
 *     - int[] money: 사용 가능한 동전 단위 (최대 100종류)
 *
 * 출력  
 *     - int: 조합의 수 % 1,000,000,007
 *
 * 핵심 포인트  
 *     - 중복 조합 문제: 순서 없이 선택만 중요
 *     - 1차원 DP로 공간 최적화 가능 (dp[i]: i원을 만들 수 있는 조합 수)
 *     - 조합의 순서 고려하지 않도록 화폐 단위 기준으로 외부 루프
 *     - 모듈러 연산을 매 루프마다 적용해 오버플로우 방지
 */

class Solution {
	
	public int solution(int n, int[] money) {
		long[] dp = new long[n + 1];
		dp[0] = 1; // 금액 0을 만드는 방법은 1가지 (아무것도 안 씀)
		
		// 각 화폐 단위에 대해 조합 누적
		for (int i = 0; i < money.length; i++) {
			int cur = money[i];
			for (int j = cur; j <= n; j++) {
				dp[j] += dp[j - cur];
				dp[j] %= 1_000_000_007;
			}
		}
		
		return (int) dp[n];
	}
	
}
